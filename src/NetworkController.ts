import { ThreeDRotationSharp } from "@material-ui/icons";
import { Dataset, Dataset2D, DatasetGenerator } from "./datasets";
import * as nn from "./NeuralNet";

interface InputFunc {
    f: (x: number, y: number) => number;
    label: string;
}

let ACTIVATIONS: { [name: string]: nn.ActivationFunction } = {
    "Tanh": nn.Activations.TANH,
    "ReLU": nn.Activations.RELU,
    "Sigmoid": nn.Activations.SIGMOID,
}

let GENERATORS: { [datasetType: string]: DatasetGenerator } = {
    "Gaussian2": Dataset.GAUSSIAN_2,
    "Gaussian3": Dataset.GAUSSIAN_3,
    "XOR": Dataset.XOR,
}


export let INPUTS: { [name: string]: InputFunc } = {
    "x": { f: (x, y) => x, label: "X_1" },
    "y": { f: (x, y) => y, label: "X_2" },
    "xSquared": { f: (x, y) => x * x, label: "X_1^2" },
    "ySquared": { f: (x, y) => y * y, label: "X_2^2" },
    "xTimesY": { f: (x, y) => x * y, label: "X_1X_2" },
    "sinX": { f: (x, y) => Math.sin(x), label: "sin(X_1)" },
    "sinY": { f: (x, y) => Math.sin(y), label: "sin(X_2)" },
};


/** Stores network and network configuration state and actions. */
export interface NNConfig {
    networkShape: number[];
    activationFunction: string;
    learningRate: number;
    inputs: { [key: string]: boolean };
    batchSize: number;
    noise: number;
    datasetType: string;
    dataset: Dataset2D[];
    decisionBoundaries: { [nodeId: string]: number[] };
    decisionBoundary: number[];
    loss: number;
    epochs: number;
    lossData: [number, number][]; // Maybe loss data shouldn't be dealt with inside of NetworkController (Maybe have a whole data storage and analysis class/controller)
    numSamples: number;
}

// Maybe there should only be one input 
// Maybe rename or split this up differently
// Or split this up into properties that are needed to define a network and ones that are generated by the network
export interface NetworkState {
    noise: number;
    datasetType: string;
    dataset: Dataset2D[];
    config: NNConfig;
    decisionBoundaries: { [nodeId: string]: number[] };
    decisionBoundary: number[];
    loss: number;
    epochs: number;
    lossData: [number, number][];
}

// Maybe each saved state should have it's own controller

export class NetworkController {

    network: nn.Node[][];
    dataset: Dataset2D[];

    // Maybe instead extract config for easier access
    // config: NNConfig;

    compareMode: boolean;

    trainingData: Dataset2D[];
    testData: Dataset2D[];

    networkShape: number[];
    activationFunction: string;
    learningRate: number;
    inputs: { [key: string]: boolean };
    batchSize: number;
    noise: number;
    datasetType: string;
    // dataset: Dataset2D[];
    decisionBoundaries: { [nodeId: string]: number[] };
    decisionBoundary: number[];
    loss: number;
    epochs: number;
    lossData: [number, number][]; // Maybe loss data shouldn't be dealt with inside of NetworkController (Maybe have a whole data storage and analysis class/controller)
    numSamples: number;

    // REFACTOR: Maybe split this up differently
    // networkProperties: NetworkState;

    // constructor(config: NNConfig/* , temp: NetworkController */) {
    //     console.log("Constructing NetworkController");
    //     this.config = config;
    //     /* networkProperties = temp; */
    //     this.network = nn.generateNetwork(config.networkShape, ACTIVATIONS[config.activationFunction], nn.Activations.TANH, config.inputs);
    //     this.dataset = this.getDataset(config.datasetType, config.numSamples, config.noise);
    //     [this.trainingData, this.testData] = this.splitDataset(this.dataset);

    //     this.compareMode = false;

    //     console.log(this.network);
    //     // this.generateNetwork();
    // }

    constructor(config: NNConfig/* , temp: NetworkController */) {
        console.log("Constructing NetworkController");
        
        this.networkShape = config.networkShape;
        this.activationFunction = config.activationFunction;
        this.learningRate = config.learningRate;
        this.inputs = config.inputs;
        this.batchSize = config.batchSize;
        this.noise = config.noise;
        this.datasetType = config.datasetType;
        this.decisionBoundaries = config.decisionBoundaries;
        this.decisionBoundary = config.decisionBoundary;
        this.loss = config.loss;
        this.epochs = config.epochs;
        this.lossData = config.lossData;
        this.numSamples = config.numSamples;
        // remove all constant default values (e.g. loss will always default to 0)

        this.network = nn.generateNetwork(this.networkShape, ACTIVATIONS[this.activationFunction], nn.Activations.TANH, this.inputs);
        this.dataset = this.getDataset(this.datasetType, this.numSamples, this.noise);
        [this.trainingData, this.testData] = this.splitDataset(this.dataset);


        this.compareMode = false;

        console.log(this.network);
        // this.generateNetwork();
    }

    // export function start(config: NNConfig): nn.Node[][] {
    //     let network = nn.generateNetwork(config.networkShape, ACTIVATIONS[config.activationFunction], nn.Activations.TANH, config.inputs);
    //     console.log(network);
    
    //     return network;
    // }
    
    private getDataset(datasetType: string, numSamples: number, noise: number) {
        let datasetGenerator = GENERATORS[datasetType];
        let dataset = datasetGenerator(numSamples, noise);
        // console.log(dataset);
        return dataset;
    }
    
    private constructInputs(x: number, y: number, inputs: { [key: string]: boolean }): number[] {
        let constructedInputs: number[] = [];
        for (let inputName in INPUTS) {
            if (inputs[inputName]) constructedInputs.push(INPUTS[inputName].f(x, y))
        }
        // console.log("X:" + x + " Y:"+ y)
        // console.log(constructedInputs)
        return constructedInputs;
    }

    private splitDataset(dataset: Dataset2D[]) {
        let testDataIndex = Math.floor(dataset.length * 0.8);
        let trainingData = dataset.slice(0, testDataIndex);
        let testData = dataset.slice(testDataIndex, dataset.length);
        return [trainingData, testData];
    }
    
//    step(network: nn.Node[][], trainingData: Dataset2D[], learningRate: number, inputs: { [key: string]: boolean }, batchSize: number): void {
//         for (let i = 0; i < trainingData.length; i++) {
//             let sample = trainingData[i];
//             nn.forwardPropagate(network, constructInputs(sample.x1, sample.x2, inputs));
//             nn.backPropagate(network, nn.Costs.SQUARE, sample.y);
//             if ((i + 1) % batchSize === 0) nn.train(network, learningRate);
//         }
    
//     }

    step(): void {
        for (let i = 0; i < this.trainingData.length; i++) {
            let sample = this.trainingData[i];
            nn.forwardPropagate(this.network, this.constructInputs(sample.x1, sample.x2, this.inputs));
            nn.backPropagate(this.network, nn.Costs.SQUARE, sample.y);
            if ((i + 1) % this.batchSize === 0) nn.train(this.network, this.learningRate); // Passing by reference/value here might cause issues
        }
    }
    
    // getCost(network: nn.Node[][], data: Dataset2D[], inputs: { [key: string]: boolean }/* , costFunction: nn.CostFunction */): number {
    //     let totalCost = 0;
    //     for (let i = 0; i < data.length; i++) {
    //         let dataPoint = data[i];
    //         totalCost += nn.Costs.SQUARE.cost(nn.forwardPropagate(network, constructInputs(dataPoint.x1, dataPoint.x2, inputs)), dataPoint.y);
    //     }
    
    //     return totalCost / data.length;
    // }

    // Maybe this should be private
    getCost(dataset: Dataset2D[]): number {
        let totalCost = 0;
        for (let i = 0; i < dataset.length; i++) {
            let dataPoint = dataset[i];
            totalCost += nn.Costs.SQUARE.cost(nn.forwardPropagate(this.network, this.constructInputs(dataPoint.x1, dataPoint.x2, this.inputs)), dataPoint.y);
        }
        return totalCost / dataset.length;
    }
    
    // export function copyNetwork(network: nn.Node[][]): nn.Node[][] {
    //     return nn.copyNetwork(network);
    // }
    
    // export function getOutputDecisionBoundary(network: nn.Node[][], density: number, xDomain: number[], yDomain: number[], inputs: { [key: string]: boolean }): Dataset2D[] {
    
    //     let xScale = d3.scaleLinear().domain([0, density]).range(xDomain);
    //     let yScale = d3.scaleLinear().domain([density, 0]).range(yDomain);
    //     let boundary: Dataset2D[] = [];
    
    //     for (let i = 0; i < density; i++) {
    //         for (let j = 0; j < density; j++) {
    //             let x = xScale(j);
    //             let y = yScale(i);
    
    //             let input = constructInputs(x || 0, y || 0, inputs);
    //             nn.forwardPropagate(network, input);
    
    //             let dataPoint: Dataset2D = { x1: x || 0, x2: y || 0, y: nn.getOutputNode(network).output }
    
    //             boundary.push(dataPoint);
    //         }
    //     }
    
    //     return boundary;
    // }

    // Maybe this should be private and replace get with generate
    // getOutputDecisionBoundary(): Dataset2D[] {
    
    //     let xScale = d3.scaleLinear().domain([0, density]).range(xDomain);
    //     let yScale = d3.scaleLinear().domain([density, 0]).range(yDomain);
    //     let boundary: Dataset2D[] = [];
    
    //     for (let i = 0; i < density; i++) {
    //         for (let j = 0; j < density; j++) {
    //             let x = xScale(j);
    //             let y = yScale(i);
    
    //             let input = constructInputs(x || 0, y || 0, inputs);
    //             nn.forwardPropagate(network, input);
    
    //             let dataPoint: Dataset2D = { x1: x || 0, x2: y || 0, y: nn.getOutputNode(network).output }
    
    //             boundary.push(dataPoint);
    //         }
    //     }
    

    //     return boundary;
    // }
    
    // export function getOutputDecisionBoundary1D(network: nn.Node[][], density: number, xDomain: number[], yDomain: number[], inputs: { [key: string]: boolean }): number[] {
    
    //     let xScale = d3.scaleLinear().domain([0, density]).range(xDomain);
    //     let yScale = d3.scaleLinear().domain([density, 0]).range(yDomain);
    //     let boundary: number[] = [];
    //     let iter = 0;
    
    //     for (let i = 0; i < density; i++) {
    //         for (let j = 0; j < density; j++) {
    //             let x = xScale(j);
    //             let y = yScale(i);
    
    //             let input = constructInputs(x || 0, y || 0, inputs);
    //             nn.forwardPropagate(network, input);
    
    //             boundary[iter++] = nn.getOutputNode(network).output;
    //         }
    //     }
    
    //     return boundary;
    // }
    
    // export function getAllDecisionBoundaries(network: nn.Node[][], density: number, xDomain: number[], yDomain: number[], inputs: { [key: string]: boolean }): { [nodeId: string]: number[] } {
    //     let boundaries: { [nodeId: string]: number[] } = {};
    
    //     let xScale = d3.scaleLinear().domain([0, density]).range(xDomain);
    //     let yScale = d3.scaleLinear().domain([density, 0]).range(yDomain);
    //     let iter = 0;
    
    //     let inputNodeIds = Object.keys(INPUTS);
    
    //     for (let i = 0; i < density; i++) {
    //         for (let j = 0; j < density; j++) {
    //             let x = xScale(j);
    //             let y = yScale(i);
    
    //             let input = constructInputs(x || 0, y || 0, inputs);
    //             nn.forwardPropagate(network, input);
    //             nn.forEachNode(network, (node: nn.Node) => {
    //                 if (!boundaries[node.id]) boundaries[node.id] = [];
    //                 boundaries[node.id][iter] = node.output;
    //             })
    //             inputNodeIds.forEach((nodeId) => {
    //                 if (!boundaries[nodeId]) boundaries[nodeId] = [];
    //                 boundaries[nodeId][iter] = INPUTS[nodeId].f(x || 0, y || 0);
    //             })
    //             iter++;
    //             //boundary[iter++] = nn.getOutputNode(network).output;
    //         }
    //     }
    
    //     return boundaries;
    
    // }
    
    
    
    generateNetwork(): void {
        // this.net
    }

    generateDataset(): void {

    }

    reset(): void {
        this.network = nn.generateNetwork(this.networkShape, ACTIVATIONS[this.activationFunction], nn.Activations.TANH, this.inputs);
        this.dataset = this.getDataset(this.datasetType, this.numSamples, this.noise);
        [this.trainingData, this.testData] = this.splitDataset(this.dataset);
    }

    
}